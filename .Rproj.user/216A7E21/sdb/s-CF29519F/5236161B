{
    "collab_server" : "",
    "contents" : "# These functions do things that require parameter estimates\n# But\n\n# 0. Prior specification\npriorRho <- function(rho, alpha=1) {\n  priorDensity <- 2^(1-2*alpha)*(1-rho^2)^(alpha-1)\n  logNormalisationConstant <- -lbeta(alpha, alpha)\n  result <- exp(logNormalisationConstant)*priorDensity\n  return(result)\n}\n\npriorRhoPlus <- function(rho, alpha=1) {\n  nonNegativeIndex <- rho >=0\n  lessThanOneIndex <- rho <=1\n  valueIndex <- as.logical(nonNegativeIndex*lessThanOneIndex)\n  myResult <- rho*0\n\n  myResult[valueIndex] <- 2*priorRho(rho[valueIndex], alpha)\n  return(myResult)\n}\n\n# 1.0. Built-up for likelihood functions\njeffreysApproxH <- function(n, r, rho) {\n  return(((1 - rho^(2))^(0.5*(n - 1)))/((1 - rho*r)^(n - 1 - 0.5)))\n}\n\n\n\n# 2.1 Two-sided main Bayes factor\n# See Ly et al 2014 or 2015\n\n# 2.2 Two-sided secondairy Bayes factor\nbf10JeffreysIntegrate <- function(n, r, alpha=1) {\n  # Jeffreys' test for whether a correlation is zero or not\n  # Jeffreys (1961), pp. 289-292\n  # This is the exact result, see EJ\n  ##\n  if ( any(is.na(r)) ){\n    return(NaN)\n  }\n\n  # TODO: use which\n  if (n > 2 && abs(r)==1) {\n    return(Inf)\n  }\n\n  hyperTerm <- Re(hypergeo::hypergeo((2*n-3)/4, (2*n-1)/4, (n+2*alpha)/2, r^2))\n  logTerm <- lgamma((n+2*alpha-1)/2)-lgamma((n+2*alpha)/2)-lbeta(alpha, alpha)\n  myResult <- sqrt(pi)*2^(1-2*alpha)*exp(logTerm)*hyperTerm\n  return(myResult)\n}\n\n\n# 3.0 One-sided preparation\n\nmPlusMarginalBJeffreys <- function(n, r, alpha=1){\n  # Ly et al 2014\n  # This is the exact result with symmetric beta prior on rho\n  # This is the contribution of one-sided test\n  #\n  #\n  if ( any(is.na(r)) ){\n    return(NaN)\n  }\n  if (n > 2 && r>=1) {\n    return(Inf)\n  } else if (n > 2 && r<=-1){\n    return(0)\n  }\n\n  hyperTerm <- Re(genhypergeo(U=c(1, (2*n-1)/4, (2*n+1)/4),\n                              L=c(3/2, (n+1+2*alpha)/2), z=r^2))\n  logTerm <- -lbeta(alpha, alpha)\n  myResult <- 2^(1-2*alpha)*r*(2*n-3)/(n+2*alpha-1)*exp(logTerm)*hyperTerm\n  return(myResult)\n}\n\n\nbfPlus0JeffreysIntegrate <- function(n, r, alpha=1){\n  # Ly et al 2014\n  # This is the exact result with symmetric beta prior on rho\n  #\n  if ( any(is.na(r)) ){\n    return(NaN)\n  }\n  if (n > 2 && r>=1) {\n    return(Inf)\n  } else if (n > 2 && r<=-1){\n    return(0)\n  }\n\n  bf10 <- bf10JeffreysIntegrate(n, r, alpha)\n  mPlus <- mPlusMarginalBJeffreys(n, r, alpha)\n\n  if (is.na(bf10) || is.na(mPlus)){\n    return(NA)\n  }\n\n  myResult <- bf10+mPlus\n  return(myResult)\n}\n\n\n\n###############################################################################\n### Compute Bayes factors for Pearson's correlation coefficient\n###\n### Last revised: 06-01-2015\n### Author: Josine Verhagen, Alexander Ly\n### www.alexander-ly.com\n# See Wagenmakers, E.-J., Verhagen, A. J. & Ly, A. (2015).\n# \tHow to quantify the evidence for the absence of a correlation\n# \t\tManuscript submitted for publication.\n#\n###############################################################################\n#\n# TODOTODO: check code for robustness.\n\nestimationPosteriorU <- function(rho, n, r, alpha=1){\n  dataTerm <- (1-rho^2)^((n-1)/2)/((1-rho*r)^((2*n-3)/2))*priorRho(rho, alpha)\n  hyperTerm <- Re(hypergeo(1/2, 1/2, (2*n-1)/2, 1/2+1/2*r*rho))\n  myResult <- dataTerm*hyperTerm\n  return(myResult)\n}\n\nestimationPosteriorNormalisationConstant <- function(n, r, alpha=1){\n  # The normalisation constant for the replication Bayes factor\n  integrand <- function(x){estimationPosteriorU(x, n, r, alpha)}\n  myResult <- integrate(integrand, -1, 1)$value\n  return(myResult)\n}\n\nestimationPosterior <- function(rho, n, r, alpha=1){\n  normalisationConstant <- estimationPosteriorNormalisationConstant(n, r, alpha)\n  myResult <- 1/normalisationConstant*estimationPosteriorU(rho, n, r, alpha)\n  return(myResult)\n}\n\nrepPrior <- function(rho, nOri, rOri){\n  estimationPosterior(rho, n=nOri, r=rOri)\n}\n\n# repPriorU <- function(rho, nOri, rOri){\n# \tdataTerm <- (1-rho^2)^((nOri-1)/2)/((1-rho*rOri)^((2*nOri-3)/2))\n# \thyperTerm <- Re(hypergeo(1/2, 1/2, (2*nOri-1)/2, 1/2+1/2*rOri*rho))\n# \tmyResult <- dataTerm*hyperTerm\n# \treturn(myResult)\n# }\n#\n# repPriorNormalisationConstant <- function(nOri, rOri){\n# \t# The normalisation constant for the replication Bayes factor\n# \tintegrand <- function(x){repPriorU(x, nOri, rOri)}\n# \tmyResult <- integrate(integrand, -1, 1)$value\n# \treturn(myResult)\n# }\n#\n# repPrior <- function(rho, nOri, rOri){\n# \tnormalisationConstant <- repPriorNormalisationConstant(nOri, rOri)\n# \tmyResult <- 1/normalisationConstant*repPriorU(rho, nOri, rOri)\n# \treturn(myResult)\n# }\n\nrepPosteriorU <- function(rho, nOri, rOri, nRep, rRep){\n  # Unnormalised posterior for the replication Bayes factor\n  dataTerm <- (1-rho^2)^((nOri+nRep-2)/2)/((1-rho*rRep)^((2*nRep-3)/2)*(1-rho*rOri)^((2*nOri-3)/2))\n  hyperTerm <- Re(hypergeo(1/2, 1/2, (2*nOri-1)/2, 1/2+1/2*rOri*rho))\n  myResult <- dataTerm*hyperTerm\n  return(myResult)\n}\n\nrepPosteriorNormalisationConstant <- function(nOri, rOri, nRep, rRep){\n  # The normalisation constant for the replication Bayes factor\n  integrand <- function(x){repPosteriorU(x, nOri, rOri, nRep, rRep)}\n  myResult <- integrate(integrand, -1, 1)$value\n  return(myResult)\n}\n\nrepPosterior <- function(rho, nOri, rOri, nRep, rRep){\n  normalisationConstant <- repPosteriorNormalisationConstant(nOri, rOri, nRep, rRep)\n  myResult <- 1/normalisationConstant*repPosteriorU(rho, nOri, rOri, nRep, rRep)\n  return(myResult)\n}\n\nrepBfR0 <- function(rho=0, nOri, rOri, nRep, rRep){\n  myResult <- repPrior(rho, nOri, rOri)/repPosterior(rho, nOri, rOri, nRep, rRep)\n  return(myResult)\n}\n\n# Just some plotting\nplotRhoPrior <- function(gammas){\n  numberOfGammas <- length(gammas)\n\n  myDomain <- seq(-1, 1, by=0.01)\n  collectionOfPriors <- array(dim=c(numberOfGammas, length(myDomain)))\n\n  for (i in 1:numberOfGammas){\n    collectionOfPriors[i, ] <- priorRho(myDomain, alpha=1/gammas[i])\n  }\n\n  yLim <- max(collectionOfPriors)\n\n  par(cex.main=1.5, mar=c(5, 6, 4, 5) + 0.1, mgp=c(3.5, 1, 0), cex.lab=1.5,\n      font.lab=2, cex.axis=1.3, bty=\"n\", las=1)\n  plot(x=NULL, y=NULL, xlim=c(-1, 1), ylim=c(0, yLim),\n       ylab=\"Prior density\", xlab=expression(paste(\"Correlation \", rho)))\n\n  for (i in 1:numberOfGammas){\n    lines(myDomain, collectionOfPriors[i, ], col=i, lwd=2.5, lty=2)\n  }\n\n  legendText <- vector(, numberOfGammas)\n\n  for (i in 1:numberOfGammas){\n    legendText[i] <- paste(expression(gamma), \"=\", round(gammas[i], 2))\n  }\n\n\n  legend('topright', legend=legendText,\n         lty=2, col=1:numberOfGammas, bty='n', cex=1.2, lwd=2)\n}\n\n\nplotSensitivity <- function(BF01s, myGamma, xLegend=0.52, arrowCorrect=0.3,\n                            arrowStartHeight=1.25, arrowEndHeight=0.15,\n                            textHeight=2.25){\n  par(cex.main=1.5, mar=c(3, 5, 4, 2) + 0.1, mgp=c(2, 0.25, 0),\n      cex.lab=1.5, font.lab=2, cex.axis=1.3, bty=\"n\", las=1)\n\n  plot(myGamma, log(BF01s), xlab=expression(gamma), ylab=\"\", ylim=c(-log(3), log(100)),\n       xlim=c(0, 1), main=\"Study 1\", axes=FALSE, lwd=2.5, type=\"l\")\n\n\n  axis(1, at=seq(0, 1, by=0.25))\n  axis(2, tcl=0, labels=c(\"-log(10)\", \"-log(3)\", \"log(1)\", \"log(3)\", \"log(10)\",\n                          \"log(30)\", \"log(100)\"), at=c(-log(10), -log(3),\n                                                       log(1), log(3), log(10),\n                                                       log(30), log(100)))\n\n  abline(h=c(-log(10),-log(3), log(1),log(3),log(10),log(30),log(100)),\n         col='grey', lwd=2, lty=2)\n  abline(h=c(log(1)), col='darkgrey',lwd=2,lty=2)\n\n  spreadOneIndex <- which(myGamma==1)\n  points(1, log(BF01s[spreadOneIndex]), lwd=3)\n\n\n  BFNumber <- round(BF01s[spreadOneIndex], 2)\n\n  # Change BF01s[spreadOneIndex] to analyticBF01[studyNumber]\n  arrows(x0=myGamma[spreadOneIndex]-arrowCorrect,\n         y0=log(BF01s[spreadOneIndex]*exp(arrowStartHeight)),\n         x1=myGamma[spreadOneIndex],\n         y1=log(BF01s[spreadOneIndex]*exp(arrowEndHeight)),\n         col=\"black\", lwd=2, length=0.12)\n\n  legend(xLegend, log(BF01s[spreadOneIndex]*exp(textHeight)),\n         substitute(BF[0][1]==BFNumber, list(BFNumber=BFNumber)),\n         bty=\"n\", cex=1.7)\n}\n\nplotRhoPosterior <- function(n, r, alpha=1){\n  numberOfGammas <- length(gammas)\n\n  myDomain <- seq(-1, 1, by=0.01)\n  collectionOfPriors <- array(dim=c(numberOfGammas, length(myDomain)))\n\n  for (i in 1:numberOfGammas){\n    collectionOfPriors[i, ] <- priorRho(myDomain, alpha=1/gammas[i])\n  }\n\n  yLim <- max(collectionOfPriors)\n  yLim <- 28\n  par(cex.main=1.5, mar=c(5, 6, 4, 5) + 0.1, mgp=c(3.5, 1, 0), cex.lab=1.5,\n      font.lab=2, cex.axis=1.3, bty=\"n\", las=1)\n  plot(x=NULL, y=NULL, xlim=c(-1, 1), ylim=c(0, yLim),\n       ylab=\"Prior density\", xlab=expression(paste(\"Correlation \", rho)))\n\n  for (i in 1:numberOfGammas){\n    lines(myDomain, collectionOfPriors[i, ], col=i, lwd=2.5)\n  }\n\n  legendText <- vector(, numberOfGammas)\n\n  for (i in 1:numberOfGammas){\n    legendText[i] <- paste(expression(gamma), \"=\", round(gammas[i], 2))\n  }\n\n\n  legend('topright', legend=legendText,\n         lty=1, col=1:numberOfGammas, bty='n', cex=1.2, lwd=2)\n}\n\n#  Useless\nmakeGammas <- function(n){\n  myGamma <- sin(seq(1.5*pi, 2*pi, length=n))+1\n  myGamma[1] <- myGamma[2]/10\n  myGamma[n] <- 1\n  return(myGamma)\n}\n\nplotRhoPriorPosterior <- function(n, r, alpha, yLim=10){\n  rhoDomain <- seq(-1, 1, by=0.001)\n\n  myGamma <- round(1/alpha, 2)\n  myTitle <- substitute(paste(\"Prior and posterior with scale \", gamma, \"=\", v), list(v=myGamma))\n\n  par(cex.main=1.5, mar=c(5, 6, 4, 5) + 0.1, mgp=c(3.5, 1, 0), cex.lab=1.5,\n      font.lab=2, cex.axis=1.3, bty=\"n\", las=1)\n\n  plot(x=NULL, y=NULL, xlim=c(-1, 1), ylim=c(0, yLim), axes=FALSE,\n       xlab=expression(paste(\"Correlation \", rho)), ylab=\"Density\",\n       main=myTitle)\n\n  # Prior\n  somePrior <- priorRho(rhoDomain, alpha)\n  priorNull <- priorRho(0, alpha)\n  lines(rhoDomain, y=somePrior, lty=2, lwd=2.5)\n\n  # Posterior posterior(myDomain\n  somePosterior <- estimationPosterior(rhoDomain, n=n, r=r, alpha=alpha)\n  posteriorNull <- estimationPosterior(0, n=n, r=r, alpha=alpha)\n\n  lines(rhoDomain, somePosterior, lwd=2.5)\n\n  # Draw Savage Dickey points\n  points(0, priorNull, pch=19, cex=2.5, col=\"grey\")\n  points(0, posteriorNull, pch=19, cex=2.5, col=\"grey\")\n  points(0, priorNull, pch=21, cex=2.5, col=\"black\")\n  points(0, posteriorNull, pch=21, cex=2.5, col=\"black\")\n  axis(1)\n  axis(2)\n\n\n  legendText <- c(\"Prior\", \"Posterior\")\n\n  legend(\"topleft\", legend=legendText,\n         lty=c(2, 1), bty=\"n\", cex=1.5)\n}\n\ncountNonNAEntries <- function(x, y){\n  xCheck <- as.numeric(!is.na(x))\n  yCheck <- as.numeric(!is.na(y))\n  sum(xCheck*yCheck)\n}\n\n\ngiveBF<-function(input){\n  returnvalue = \"\"\n  if(input <1){\n    returnvalue = paste0(\" = \",sprintf(\"%.3f\",input))\n  }\n  if(input>1 && input < 100 ){\n    returnvalue = paste0(\" = \", round(input,2))\n  }\n\n  if(input>100){\n    returnvalue = paste0(\" = \", round(input))\n  }\n\n  if(input>1000){\n    returnvalue = \"> 1000\"\n  }\n  if(input < 1/1000){\n    returnvalue = \"< 0.001\"\n  }\n  return(returnvalue)\n}\n\n\n\nDoCorr<-function(x.name,y.name,data){\n\n  x = data[,x.name]\n  y = data[,y.name]\n\n  df<-data.frame(x = x, y = y)\n  df<-df[complete.cases(df),]\n  x = df$x\n  y = df$y\n\n  # check if the bayesian correlation can already been run\n  if(run.bayes == TRUE){\n\n    the.file = paste0(\"corr.\",x.name,\"_\",y.name,\".roj\")\n    if(file.exists(the.file)  == TRUE){\n      robj = read.BayesCorrObj(x.name,y.name)\n    }\n  }\n\n\n  if(run.bayes == FALSE){\n\n\n\n    cor.obj = cor.test(x,y)\n\n    robj = list()\n    robj$fit = NULL\n    robj$dist = NULL\n    robj$cor$r.estimate = cor.obj\n    robj$cor$rho = unname(cor.obj$estimate)\n    robj$cor$n = length(x)\n    robj$cor$bfAlt = bf10JeffreysIntegrate(n = robj$cor$n, r = robj$cor$rho )\n    robj$cor$bfAltText = giveBF(robj$cor$bfAlt)\n    robj$cor$bfNull = 1/bf10JeffreysIntegrate(n = robj$cor$n, r = robj$cor$rho )\n    robj$cor$bfNullText = giveBF(robj$cor$bfNull)\n    robj$cor$bfEvidence = NULL\n    robj$cor$bfHypothesis = NULL\n    robj$cor$x.mean = mean(x)\n    robj$cor$y.mean = mean(y)\n    robj$cor$x.name = x.name\n    robj$cor$y.name = y.name\n    robj$cor$x.data = x\n    robj$cor$y.data = y\n    robj$cor$hdi = cor.obj$conf.int[c(1,2)]\n    robj$cor$sig = cor.obj$p.value\n    robj$mcmc = NULL\n\n  }\n\n  return(robj)\n}\n\nParseCor<-function(corobj){\n\n  return(paste0(paste0(\"*r* = \",weights::rd(corobj$cor$rho)),\", \",\n         paste0(\"95% HDI[\",paste0(weights::rd(corobj$cor$hdi),collapse = \"; \"),\"]\"),\", \",\n         paste0(\"*BF*~10~ \",corobj$cor$bfAltText),\", \",\n         paste0(\"*BF*~01~ \",corobj$cor$bfNullText)))\n}\n\n\nDoMean<-function(data){\n\n  data = na.omit(data)\n\n  if(run.bayes == T){\n    cat(\"whooops!\")\n  }\n\n  if(run.bayes == F){\n\n  }\n}\n\n\n\n\n",
    "created" : 1510246505656.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3600992672",
    "id" : "5236161B",
    "lastKnownWriteTime" : 1510251070,
    "last_content_update" : 1510251070530,
    "path" : "~/GitHub/rara/R/DoCorr.R",
    "project_path" : "R/DoCorr.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}